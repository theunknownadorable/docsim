from flask import Flask, render_template, request, jsonify, session
import random
import json
from datetime import datetime
import difflib
import google.generativeai as genai

app = Flask(__name__)
app.secret_key = 'your-secret-key-here'  # Change this in production

# Configure Gemini API
genai.configure(api_key='AIzaSyC-E4Bo4qu4W5H4SWhJBZ9GBRCu5Gx6Euw')
model = genai.GenerativeModel('gemini-2.5-flash')

def generate_case_with_gemini():
    """Generate a medical case using Gemini API"""
    prompt = """Generate a realistic medical case for a diagnostic simulator with the following structure:
    {
        "patient_history": "[demographics and medical history]",
        "symptoms": "[presenting symptoms]",
        "vital_signs": {
            "blood_pressure": "[value]",
            "heart_rate": "[value]",
            "temperature": "[value]",
            "respiratory_rate": "[value]"
        },
        "available_tests": ["list", "of", "relevant", "tests"],
        "correct_diagnosis": "[correct diagnosis]",
        "differential_diagnoses": ["list", "of", "differentials"],
        "explanation": "[detailed explanation of diagnosis]",
        "consequences": "[potential consequences of misdiagnosis]"
    }
    Make it realistic and challenging for medical students."""
    
    response = model.generate_content(prompt)
    try:
        return json.loads(response.text)
    except json.JSONDecodeError:
        raise ValueError("Failed to generate case with Gemini")

def evaluate_diagnosis_with_gemini(submitted_diagnosis, correct_diagnosis):
    """Evaluate diagnosis using Gemini for nuanced medical accuracy"""
    prompt = f"""Evaluate if these two medical diagnoses are similar or related:
    Submitted: {submitted_diagnosis}
    Correct: {correct_diagnosis}
    
    Return JSON with these fields:
    {
        "is_correct": boolean (true if exactly matches),
        "is_partially_correct": boolean (true if related diagnosis),
        "similarity_score": float (0-1),
        "explanation": string (brief medical explanation of relationship)
    }"""
    
    response = model.generate_content(prompt)
    try:
        return json.loads(response.text)
    except json.JSONDecodeError:
        return {
            "is_correct": False,
            "is_partially_correct": False,
            "similarity_score": 0,
            "explanation": "Unable to evaluate diagnosis relationship"
        }

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/simulator')
def simulator():
    return render_template('simulator.html')

@app.route('/api/new_case')
def new_case():
    """Get a new case generated by Gemini"""
    case = generate_case_with_gemini()
    # Generate a random ID for the case
    case['id'] = random.randint(1000, 9999)
    # Store current case in session
    session['current_case'] = case
    # Don't send the answers back to the frontend
    safe_case = {
        'id': case['id'],
        'patient_history': case['patient_history'],
        'symptoms': case['symptoms'],
        'vital_signs': case['vital_signs'],
        'available_tests': case['available_tests']
    }
    return jsonify(safe_case)

@app.route('/api/order_test', methods=['POST'])
def order_test():
    """Order a laboratory test"""
    data = request.get_json()
    test_name = data.get('test_name')
    
    current_case = session.get('current_case')
    if not current_case:
        return jsonify({'error': 'No active case'}), 400
    
    # Generate realistic test results with Gemini
    prompt = f"""Given this patient case:
    History: {current_case['patient_history']}
    Symptoms: {current_case['symptoms']}
    Vital Signs: {json.dumps(current_case['vital_signs'])}
    
    Generate a realistic result for the {test_name} test that would be consistent with the diagnosis of {current_case['correct_diagnosis']}.
    Return just the test result as a string (no JSON formatting)."""
    
    response = model.generate_content(prompt)
    result = response.text if response.text else "Test result pending"
    
    return jsonify({'test_name': test_name, 'result': result})

@app.route('/api/submit_diagnosis', methods=['POST'])
def submit_diagnosis():
    """Submit diagnosis and get feedback"""
    data = request.get_json()
    submitted_diagnosis = data.get('diagnosis', '').strip()
    
    current_case = session.get('current_case')
    if not current_case:
        return jsonify({'error': 'No active case'}), 400
    
    correct_diagnosis = current_case['correct_diagnosis']
    evaluation = evaluate_diagnosis_with_gemini(submitted_diagnosis, correct_diagnosis)
    
    # Use Gemini's evaluation for correctness
    is_correct = evaluation.get('is_correct', False)
    is_partially_correct = evaluation.get('is_partially_correct', False)
    similarity = evaluation.get('similarity_score', 0)
    
    # Store the attempt in session history
    if 'diagnosis_history' not in session:
        session['diagnosis_history'] = []
    
    attempt = {
        'case_id': current_case['id'],
        'submitted_diagnosis': submitted_diagnosis,
        'correct_diagnosis': correct_diagnosis,
        'is_correct': is_correct,
        'timestamp': datetime.now().isoformat(),
        'similarity_score': similarity
    }
    
    session['diagnosis_history'].append(attempt)
    session.modified = True
    
    feedback = {
        'is_correct': is_correct,
        'is_partially_correct': is_partially_correct,
        'similarity_score': similarity,
        'correct_diagnosis': correct_diagnosis,
        'differential_diagnoses': current_case['differential_diagnoses'],
        'explanation': evaluation.get('explanation', current_case['explanation']),
        'consequences': current_case['consequences'],
        'submitted_diagnosis': submitted_diagnosis
    }
    
    return jsonify(feedback)

@app.route('/api/history')
def get_history():
    """Get diagnosis history"""
    history = session.get('diagnosis_history', [])
    return jsonify(history)

@app.route('/dashboard')
def dashboard():
    return render_template('dashboard.html')

@app.route('/about')
def about():
    return render_template('about.html')

if __name__ == '__main__':
    app.run(debug=True)
